class Solution:
    def numSquares(self, n: int) -> int:
        dp = [float('inf')]*(n+1)

        dp[0] = 0
        for i in range(1, n+1):
            for j in range(1, int(i**0.5) +1):
                dp[i] = min(dp[i],  dp[i-j*j]+1)
        return dp[-1]
# int(i**0.5) 在 for j in range(1, int(i**0.5) +1): 这行代码中有重要作用。让我们逐步理解其含义：

# i**0.5：

# i 的平方根。
# 例如，如果 i 是 9，i**0.5 就是 3.0，因为 3 的平方是 9。
# int(i**0.5)：

# 将 i 的平方根取整。
# 例如，如果 i 是 9，那么 int(i**0.5) 就是 3。
# range(1, int(i**0.5) +1)：

# 从 1 开始，到 int(i**0.5) 结束（包括 int(i**0.5)）。
# 例如，如果 i 是 9，那么 range(1, int(i**0.5) + 1) 就是 range(1, 4)，也就是 [1, 2, 3]。
# 具体作用：

# 代码 for j in range(1, int(i**0.5) +1) 的目的是枚举所有可能的平方数 j*j，其中 j 是 1 到 int(i**0.5) 之间的整数。

# 在动态规划的实现中，对于每个 i，我们检查所有可能的 j*j 使得 j*j <= i。i 需要由若干个平方数的和来表示，因此 j 从 1 到 int(i**0.5) 的所有数都要检查一遍。这是因为 j*j 是一个完全平方数，并且不能超过 i。

# 例如：

# 当 i = 12 时，int(12**0.5) 是 3。 所以 j 的范围是 [1, 2, 3]。这对应于平方数 1, 4 和 9。
# 我们需要检查 dp[i - 1*1], dp[i - 2*2] 和 dp[i - 3*3]，然后找出最小值，并加 1。
# 通过这样的检查，我们可以找到使得 dp[i] 最小的那一组平方数之和。

# 总结起来，int(i**0.5) 是为了限制 j 的最大值，确保我们只检查 i 之前的所有可能的完全平方数，从而优化我们的动态规划算法。