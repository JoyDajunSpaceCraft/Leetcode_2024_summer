# https://leetcode.com/problems/combinations/description/

# 在这个问题中，我们的目标是生成所有可能的从数字 1 到 n 的范围中选取 k 个数字的组合。这段代码使用了回溯法来解决此问题，其中 backtrack(num+1) 是关键的递归调用，保证了生成的组合中不会出现重复的元素且每个组合是有序的。现在我来解释一下为什么这里使用 num + 1 作为参数。

# 为什么使用 num + 1
# 避免重复：在组合中，我们希望每个数字只出现一次。如果在递归调用中使用 num 而不是 num + 1，则当前数字 num 会被再次使用，这可能会导致组合中有重复的数字。

# 维护顺序：我们需要的是组合而不是排列，因此顺序是不重要的。通过递归调用 backtrack(num + 1)，我们确保了在当前的数字之后只会选择更大的数字，从而避免了例如 [2, 1] 这样相对于 [1, 2] 是无效的重复组合。

# 回溯函数的工作流程
# 终止条件：当 comb（当前正在构建的组合）的长度等于 k 时，表示已经构建了一个有效的组合，因此将其添加到结果列表 res 中，并返回到上一层递归。

# 递归构建：从 start 开始到 n 结束，尝试将每个数字 num 添加到 comb 中，然后递归地调用 backtrack(num + 1) 来尝试添加下一个数字。这个递归过程会探索所有以当前 comb 开始的组合。

# 回溯：通过 comb.pop() 撤销最后一个添加的数字，这是回溯的一部分，它允许我们在返回上一层递归后用不同的数字替换当前位置，继续尝试新的组合。

# 示例
# 考虑输入 n = 4 和 k = 2，工作流程如下：

# 首先添加 1 到 comb，然后递归尝试所有以 [1] 开头的组合。
# 下一步调用 backtrack(2)，继续添加 2，得到 [1, 2]，这是一个完整的组合。
# 回溯，移除 2，然后添加 3，得到 [1, 3]。
# 继续这个过程直到探索完所有可能的组合。
# 通过这种方式，每次递归调用都确保了后续添加的数字都是当前数字之后的数字，从而有效地生成了所有的组合，并避免了无效的重复。
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        res = []
        comb = []

        def backtrack(start):
            if len(comb) == k:
                res.append(comb[:])
                return
            for num in range(start, n+1):
                comb.append(num)
                backtrack(num+1)
                comb.pop()
        backtrack(1)
        return res
